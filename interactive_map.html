<!DOCTYPE html>
<html lang="en">
   <head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <meta charset="utf-8"/>
    <title>D3 Interactive Map</title>
  </head>
  <body>
    <h1>D3 Interactive Map</h1>
    <div id="map_div">
      <svg id="map"></svg>
    </div>
    <div id="bar_chart_div">
      <svg id="bar_chart"></svg>
    </div>
  </body>

  <style>

  .line {
    fill: none;
    stroke: #000;
    stroke-width: 1.5px;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  </style>

  <script>
    const width = 800;
    const height = 600;
    const bar_height = 400;

    const centerPos = [137.0, 38.2]; // 地図のセンター位置
    const scale = 1500; // 地図のスケール

    // 地図の投影設定
    const projection = d3
      .geoMercator()
      .center(centerPos)
      .translate([width / 2, height / 2])
      .scale(scale);

    // 地図をpathに投影(変換)
    const path = d3.geoPath().projection(projection);

    // SVG要素を追加
    const svg = d3
      .select("#map_div")
      .select("svg")
      .attr("viewBox", "0 0 " + width  + " " + height)
      .attr("width", "100%")
      .attr("height", "100%")
      .attr("class", "map");

    const svg_bar = d3
      .select("#bar_chart_div")
      .select("svg")
      .attr("viewBox", "0 0 " + width  + " " + bar_height)
      .attr("width", "100%")
      .attr("height", "100%")
      .attr("class", "bar_chart");

    let render_line = d3.line().x(function(d) {
        return d[0];
      }).y(function(d) {
        return d[1];
      });

    let active_line = null;
    let lines_layer =
      svg.call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    const data = Array.from(Array(47), (v, k) => Math.random(1));
    const margin = 50;

    let xScale = d3.scaleBand().rangeRound([margin, width - margin]).padding(0.1);
    let yScale = d3.scaleLinear().rangeRound([bar_height - margin, 0]);

    d3.json("json/japan.geojson").then(function(json) {
      svg.selectAll("path")
        .data(json.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("class", "pref")
        .style("stroke", "gray")
        .style("stroke-width", 0.25)
        .style("fill", function(d,i){
          return d3.interpolateRdBu(data[i]/d3.max(data));
        });

      xScale.domain(json.features.map(function(d) {
        return d.properties.pref_j;
      }));
      yScale.domain([0, d3.max(data)]);

      svg_bar.append("g")
          .attr("class", "axis axis--x")
          .attr("transform", "translate(" + 0 + "," + (bar_height - margin) + ")")
          .call(d3.axisBottom(xScale))
          .selectAll("text")
            .attr("x", 9)
            .attr("dy", "-0.5em")
            .attr("transform", "rotate(90)")
            .style("text-anchor", "start");

      svg_bar.append("g")
          .attr("class", "axis axis--y")
          .attr("transform", "translate(" + margin + "," + 0 + ")")
          .call(d3.axisLeft(yScale));

      drawBarChart(json.features, Array.from(Array(47), (v, k) => k ));
    });

    function dragstarted() {
      activeLine = svg.append("path").datum([]).attr("class", "line");
      activeLine.datum().push(d3.mouse(this));
    }

    function dragged() {
      activeLine.datum().push(d3.mouse(this));
      activeLine.attr("d", render_line);
    }

    function dragended() {
      let selectedPref = [];
      let filterdJson = [];

      d3.selectAll(".pref")
        .each(function(d, i, node){
          let isClossed = lineClossingPolygon(d.geometry.coordinates[0], activeLine);
          if (isClossed) {
            filterdJson.push(d);
            selectedPref.push(i);
          }
          // update chart
          d3.select(this)
            .style("stroke-width", function(){
              return (isClossed)? 1.0: 0.25;
            })
            .style("stroke", function(){
              return (isClossed)? "black": "gray";
            });
        });
      if (filterdJson.length > 0) drawBarChart(filterdJson, selectedPref);
      activeLine.remove();
    }

    function lineClossingPolygon(polygon, line){
      let retVal = false;
      activeLine.datum().forEach((segment, i) => {
        if (d3.polygonContains(polygon, projection.invert(segment))) {
          retVal = true;
          return;
        }
      });
      return retVal;
    }

    function drawBarChart(json, selectedPref){
      console.log(json);

      xScale.domain(json.map(function(d) {
        return d.properties.pref_j;
      }));
      yScale.domain([0, d3.max(data)]);

      svg_bar.select(".axis--x")
          .call(d3.axisBottom(xScale));

      let updatedBars = svg_bar.selectAll(".bar")
        .data(json);

      updatedBars
        .enter()
        .append("rect")
        .transition().duration(1000)
          .attr("class", "bar")
          .attr("x", function(d) { return xScale(d.properties.pref_j); })
          .attr("y", function(d, i) { return yScale(data[selectedPref[i]]) - margin; })
          .attr("width", xScale.bandwidth())
          .attr("height", function(d, i) { return bar_height - yScale(data[selectedPref[i]]); })
          .style("fill", function(d, i){
            return d3.interpolateRdBu(data[selectedPref[i]]/d3.max(data));
          });

      updatedBars
        .transition().duration(1000)
          .attr("x", function(d) { return xScale(d.properties.pref_j); })
          .attr("y", function(d, i) { return yScale(data[selectedPref[i]]) - margin; })
          .attr("width", xScale.bandwidth())
          .attr("height", function(d, i) {
            return bar_height - yScale(data[selectedPref[i]]);
          })
          .style("fill", function(d, i){
            return d3.interpolateRdBu(data[selectedPref[i]]/d3.max(data));
          });

      updatedBars
        .exit().transition()
    	  .style("opacity","0")
    	  .attr("transform", "translate(0," + (bar_height) + ")")
    	  .remove();
    }
  </script>
</html>
